#!/usr/bin/env ruby

# Wishlist:
# Option to delete .dce_container.
# Option for using run instead of exec?

require 'yaml'

# Exception for error exit.
class DCEError < StandardError
end

class DCE
  # Run the command
  def run
    begin
      parse_args

      @conf_file = File.join(File.dirname(docker_compose_file), '.dce_container')
      config_container = nil
      if File.exists? @conf_file
        config_container = File.read @conf_file
      end

      if @query
        if config_container
          STDOUT.puts(config_container)
          exit
        end
        raise DCEError, "No container saved."
      end

      if !@container
        @container = config_container ? config_container : query_container
      end

      if @container != config_container
        File.write(@conf_file, @container)
      end

      container_id = %x{docker-compose ps -q #{@container}}.chomp
      raise DCEError, "Could not find container \"#{container}\"." unless container_id

      if @copy_keys
        container_home = %x{docker exec #{container_id} sh -c 'echo $HOME'}.chomp
        raise DCEError, "Could not find container $HOME." unless container_home

        container_ssh_dir = File.join(container_home, '.ssh')
        ssh_dir = File.join(ENV['HOME'], '.ssh')

        raise DCEError, "Could not read .ssh directory." unless FileTest.directory? ssh_dir

        ssh_files = Dir.entries(ssh_dir).collect { |name| File.join(ssh_dir, name) }.sort
        # Only keep plain files. Also weeds out the . and .. directories.
        ssh_files.select! { |file| FileTest.file? file }

        raise DCEError, "Could not create #{container_ssh_dir}." unless @dry_run or
          system "docker exec #{container_id} sh -c 'test -e #{ssh_dir} || mkdir -p #{container_ssh_dir}'"

        ssh_files.each do |file|
          base_file = File.basename(file)
          puts "Installing #{base_file}"
          destination_file = File.join(container_ssh_dir, base_file)
          command = "docker cp #{file} #{container_id}:#{destination_file}"
          system command unless @dry_run
        end

        # Ensure permissions that ssh wont complain about.
        system "docker exec #{container_id} sh -c 'chmod 700 -R #{container_ssh_dir}'"
        if @copy_keys_only
          exit
        end
      end

      # If no command given, open a shell.
      if (@command.strip.empty?)
        @command = "if [ -e /usr/bin/fish ]; then /usr/bin/fish; elif [ -e /bin/bash ]; then /bin/bash; else /bin/sh; fi"
      end

      args = '-i'
      args += 't' if STDIN.tty?
      command = "docker exec #{args} #{container_id} sh -c '#{@command}'"
      STDERR.puts "Exec'ing: " + command if @verbose
      exec command unless @dry_run
    rescue DCEError => e
      STDERR.puts(e.to_s)
      exit!
    end
  end

  # Return path to the docker-compose.yml file
  # Will exit with an error if not found
  def docker_compose_file
    unless @compose_file
      dir = Dir.pwd()
      while dir != "/"
        file = File.join(dir, 'docker-compose.yml')
        if File.exists?(file)
          @compose_file = file
          break;
        end
        dir = File.dirname(dir)
      end

      raise DCEError, "No docker-compose.yml file found." if !@compose_file
    end

    return @compose_file
  end

  # Parse command line arguments
  def parse_args
    # Not using a proper option parse library, as it will get confused
    # by options for the command given. We use a simple parser.
    while /^-/ =~ ARGV[0]
      option = ARGV.shift
      case option
      when '-c', '--container'
        @container = ARGV.shift
        raise DCEError, "Unknown container #{@container}" unless get_containers.include? @container
      when '-v', '--verbose'
        @verbose = true
      when '-n', '--dry-run'
        @verbose = true
        @dry_run = true
      when '-s', '--copy-keys'
        @copy_keys = true
      when '-S', '--copy-keys-only'
        @copy_keys = true
        @copy_keys_only = true
      when '-?', '--print-service'
        @query = true
      when '-h', '--help'
        STDERR.puts <<-HEREDOC
Usage: #{File.basename($0)} [OPTIONS]... COMMAND
Runs COMMAND in docker-compose container.

On first run, asks for the service container to use and saves it to .dce_container next
to the docker-compose.yml file.

If no command given, opens a shell.

Options:
  -c, --container SERVICE     use the container of the specified service
                              replaces the selected container in the .dce_container
  -v, --verbose               print exec'ed command
  -n, --dry-run               only print exec'ed command, don't run
  -s, --copy-keys             copy keys from $HOME/.ssh into the container
  -S, --copy-keys-only        same as the above, but don't run command or start a
                              shell
  -?, --print-service         print the service saved
  -h, --help                  print this help and exit

        HEREDOC
        exit
      else
        raise DCEError, "Unknown option #{option}"
      end
    end

    @command = ARGV.join(' ')
  end

  # Ask the user to select a container
  # The options are taken from the docker-compose.yml file
  def query_container
    containers = get_containers
    STDERR.puts "Please select container [#{containers.join(', ')}]"
    choice = STDIN.gets.strip
    exit if choice.empty?
    raise DCEError, "Illegal choice." unless !containers.include?(choice)
    choice
  end

  # Read containers from docker-compose.yml
  def get_containers
    content = YAML::load(File.read(docker_compose_file))
    content.has_key?('version') ? content['services'].keys : content.keys
  end
end

app = DCE.new
app.run
